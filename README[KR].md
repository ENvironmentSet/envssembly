#envssembly

어셈블리어를 닮은 재미있는 언어입니다.

ERun (이-런) 이라 불리는 실행기 위에서 작동합니다.


값의 타입
-------------

모든 메모리와 같은 값을 담고있는 것들은
런-타임에 자신이 담고있는 값의 타입을 따릅니다.

각 타입은 아래와 같습니다

### 1.숫자

이 언어에서 모든 숫자는 double-precision 64-bit binary format IEEE 754 입니다.
또한 10진수,16진수,8진수,2진수 표현을 지원합니다.

#### 10진수
<pre><code>
    1234567890
</code></pre>

#### 8진수
숫자 앞에 0을 붙입니다.
<pre><code>
     0755
     0123
</code></pre>


#### 2진수
숫자 앞에 0b을 붙입니다.
<pre><code>
     0b101011
     0b11111
</code></pre>


#### 16진수
숫자 앞에 0x을 붙입니다.
<pre><code>
     0x755
     0xFFA
</code></pre>

### 2.문자열

모든 문자열은 "" 에 의해 감싸져 있어야 합니다 .
(그렇지 않으면 ERun 실행기가 식별자로 인식합니다.)

<pre><code>
     "도레미파_!"
</code></pre>

식별자
-------------

식별자는 오로지 영어 알파벳으로만 작성할 수 있습니다.

또한 식별자는 라벨과 변수에게만 달 수 있습니다.

### 1.라벨

라벨은

<pre><code>
    [식별자]:
</code></pre>

형식을 띄고 있습니다.

이 부분을 라벨의 시작지점이라 부릅니다.
또한 식별자 옆에 : 뒤에는 공백과 개행을 제외하고 모든 문자의 작성이 금지되어있습니다.
한 라벨의 종료지점은 다른 라벨의 시작지점입니다.

한 라벨은 자신의 공간 (시작점-종료점)에 있는 모든 코드를 내부적으로  담고 있습니다.
또한 이 코드들을 가르키는 포인터를 내부적으로 가지고 있습니다.


### 2.변수

변수는 선언할 세그먼트에 따라 선언 방법이 달라집니다.

모든 변수의 값이 null로 초기화되는 .bss 세그먼트에서는 아래와 같이 선언합니다
<pre><code>
    .bss
    variableA
    variableB
    [식별자]
</code></pre>

변수의 값을 지정해서 초기화 할 수 있는 .data 세그먼트에서는 아래와 같습니다
 <pre><code>
     .data
     variableA "Hello, world"
     variableB 0xFFAC
     [식별자] [초기값]
 </code></pre>




세그먼트
-------------

세그먼트는 세 가지 종류가 있습니다

변수의 값을 null로 초기화하는 .bss 세그먼트
변수의 값을 지정해서 초기화 할 수 있는 .data세그먼트
메모리에 올라갈 코드를 담은 .code 세그먼트

 <pre><code>
     .data
     variableA "Hello, world"
     variableB 0xFFAC
     .bss
     variableC
     .code
     _start:
     mov ax,1
     lea bx, variableA
 </code></pre>

 주석
 -------------

 ERun 실행기는 ; 가 앞에 명시된 줄은 무시합니다.


 <pre><code>
     .data
     variableA "Hello, world"
     variableB 0xFFAC
     .bss
     variableC
     .code
     _start:
     mov ax,1
     ; 주석입니다.
     lea bx, variableA
 </code></pre>

 메모리 연산
-------------
 evssembly 에서는 메모리 주소를 가지고 연산을 할 수 있습니다.

 <pre><code>
      .bss
         variableA ; 45056 (0xB000)
      .data
         variableB "Hello, world" ;36864  (0x9000)
      .code
      lea ax, variableA ; ax = 45056 (0xB000)
      mov bx, [ax+8192]  ; 45056 - 8192 (0x9000)
      mov ax, 0
      mov cx, 13
      emucall
      exit
  </code></pre>
  ##### 간단한 메모리 연산 예제.

  [] 안에 레지스터명,숫자,+- 기호를 넣어 계산할 수 있습니다.
  []안에 평가된 수([]안의 식을 계산한 결과를 의미)는 메모리 주소로서 사용됩니다.


   명령어 사용
  -------------
  하나의 명령어는 아래와 같은 구조를 가지고 있습니다
  [명령어명 ,[피연산자] , [피연산자] ]
  하나의 명령어는 최대 두개의 피연산자를 가질 수 있습니다.

  두개의 피연산자는 , 로 구분합니다

  <pre><code>
        .code
        mov ax , 1
        exit
  </code></pre>

  ## 명령어들의 기능,피연산자  정보는 위키에서 확인해주세요.

  메인 레이블
  -------------

  하나의 프로그램은 _start 레이블을
  필수적으로 가지고 있어야 합니다.
  이 _start 레이블의 주소가 ip 레이스터의 초기값이 됩니다.
  (즉,실행시의 첫 엔트리 포인트가 된다)


  레지스터
  --------------

  ### ax 레지스터
      누산 레지스터라고도 하며 대부분의 연산에서 빠지지 않고 들어간다
      초기값은 0x0000
  ### cx 레지스터
      카운터 레지스터라고도 하며 반복문에서 반복 횟수 카운트용으로 쓰인다
      초기값은 0x0000
  ### dx 레지스터
      데이터 레지스터라고도 하며 주로 데이터 임시 저장용으로 쓰인다
      초기값은 0x0000
  ### si 레지스터
      소스 인덱스 레지스터라고도 하며 메모리 연산용으로 지겹게 쓰일거다 ㅎ
      초기값은 0x0000
  ### di 레지스터
      데스티네이션 인덱스 레지스터라고도 하며 si와 같이 쓰일거다 ㅎㅎㅎㅎㅎ
      초기값은 0x0000
  ### bx 레지스터
      베이스 레지스터라고도 불리며 주로 emucall을 할때 파라미터로 많이 쓰인다
      초기값은 0x0000
  ### bp 레지스터
      베이스 포인트 레지스터라고도 불리며
      스택의 최하단 주소를 가지고 있다
      초기값은 0xFFFF
 ### sp 레지스터
      스텍 포인트 레지스터라고도 불리며
      스택의 최상단 주소를 가지고 있다
      초기값은 0xFFFF
 ### ip 레지스터
      인스트럭션 레지스터라고도 불리며
      다음에 실행될 명령어의 주소를 가지고 있다
      초기값은 _start 레이블의 주소
### cs 레지스터
      .code 세그먼트의 최하단 주소를 가지고 있다
      초기값은 0x0000
 ### ds 레지스터
      .data 세그먼트의 최하단 주소를 가지고 있다
      초기값은 0x9000
 ### bs 레지스터
      .bss 세그먼트의 최하단 주소를 가지고 있다
      초기값은  0xB000

  Hello, world 예제
--------------------
<pre><code>
    .bss
      Hello
      ;변수 선언
    .code
      _start:
         mov Hello, "Hello, world"
         ;변수에 "Hello, world" 저장
         mov ax, 0
         ; 0번 함수 선택
         mov bx, Hello
         ; 출력할 문자열 지정
         mov cx, 13
         ; 출력할 문자열의 길이
         emucall
          ;에율레이터 0번 함수(콘솔 출력) 호출

         exit
</code></pre>